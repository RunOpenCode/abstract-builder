<?php
/*
 * This file is part of the Abstract builder package, an RunOpenCode project.
 *
 * (c) 2017 RunOpenCode
 *
 * For the full copyright and license information, please view the LICENSE
 * file that was distributed with this source code.
 */
namespace RunOpenCode\AbstractBuilder\Command;

use RunOpenCode\AbstractBuilder\Exception\RuntimeException;
use RunOpenCode\AbstractBuilder\Helper\Style;
use RunOpenCode\AbstractBuilder\Helper\Tokenizer;
use Symfony\Component\Console\Command\Command;
use Symfony\Component\Console\Input\InputArgument;
use Symfony\Component\Console\Input\InputInterface;
use Symfony\Component\Console\Input\InputOption;
use Symfony\Component\Console\Output\OutputInterface;
use Symfony\Component\Console\Question\ChoiceQuestion;
use Symfony\Component\Console\Question\Question;

/**
 * Class GenerateBuilderCommand
 *
 * @package RunOpenCode\AbstractBuilder\Command
 */
class GenerateBuilderCommand extends Command
{
    /**
     * @var Style
     */
    private $style;

    /**
     * @var InputInterface
     */
    private $input;

    /**
     * @var OutputInterface
     */
    private $output;

    /**
     * {@inheritdoc}
     */
    protected function configure()
    {
        $this
            ->setName('runopencode:generate:builder')
            ->setDescription('Generates builder class skeleton for provided class.')
            ->addArgument('class', InputArgument::OPTIONAL, 'Full qualified class name of building object that can be autoloaded, or path to file with class definition.')
            ->addArgument('builder', InputArgument::OPTIONAL, 'Full qualified class name of builder class can be autoloaded, or it will be autoloaded, or path to file with class definition.')
            ->addArgument('location', InputArgument::OPTIONAL, 'Path to location of file where builder class will be saved.')
            ->addOption('all', '-a', InputOption::VALUE_NONE, 'Should all methods be generated by default.');
    }

    /**
     * {@inheritdoc}
     */
    public function execute(InputInterface $input, OutputInterface $output)
    {
        $this->input = $input;
        $this->output = $output;
        $this->style = new Style($input, $output);

        $this->style->displayLogo();

        $this->style->title('Generate builder class');

        try {
            $buildingClass = $this->getBuildingClass();
            $this->style->info(sprintf('Builder class for class "%s" will be generated.', $buildingClass));

            $builderClass = $this->getBuilderClass(sprintf('%sBuilder', $buildingClass));
            $this->style->info(sprintf('Full qualified namespace for builder class is "%s".', $builderClass));

            $filePath = $this->getBuilderLocation($builderClass);
            $this->style->info(sprintf('Path to file where builder class will be saved is "%s".', $filePath));
            
            $methods = $this->getMethods($buildingClass, $builderClass);
            $this->style->info(sprintf('Methods to generate are: "%s()".', implode('()", "', $methods)));
        } catch (\Exception $e) {
            $this->style->error($e->getMessage());
            return 0;
        }

    }

    /**
     * Get class name for which skeleton should be built.
     *
     * @return string
     *
     * @throws \RunOpenCode\AbstractBuilder\Exception\RuntimeException
     */
    private function getBuildingClass()
    {
        $class = $this->input->getArgument('class');

        if (null === $class) {
            $helper = $this->getHelper('question');
            $question = new Question('Enter full qualified class name, or path to file with class, for which you want to generate builder class: ', null);

            $class = $helper->ask($this->input, $this->output, $question);
        }

        if (!class_exists($class, true)) {
            $class = Tokenizer::findClass($class);
        }

        if (!class_exists($class, true)) {
            throw new RuntimeException(sprintf('Unable to autoload class "%s". Does this class exists? Can it be autoloaded?', $class));
        }

        return ltrim(str_replace('\\\\', '\\', $class), '\\');
    }

    /**
     * Get class name for builder class.
     *
     * @param string $suggest
     *
     * @return string
     *
     * @throws \RunOpenCode\AbstractBuilder\Exception\RuntimeException
     */
    private function getBuilderClass($suggest)
    {
        $class = $this->input->getArgument('builder');

        if (null === $class) {
            $helper = $this->getHelper('question');
            $question = new Question(sprintf('Enter full qualified class name of your builder class (default: "%s"): ', $suggest), $suggest);

            $class = $helper->ask($this->input, $this->output, $question);
        }

        if (file_exists($class) && !class_exists($class, true)) {
            $class = Tokenizer::findClass($class);
        }

        $class = ltrim(str_replace('\\\\', '\\', $class), '\\');

        if ('' === $class) {
            throw new RuntimeException('Builder class name must be provided.');
        }

        foreach (explode('\\', $class) as $part) {

            if (!preg_match('/^[a-zA-Z_\x7f-\xff][a-zA-Z0-9_\x7f-\xff]*$/', $part)) {
                throw new RuntimeException(sprintf('Provided builder class name "%s" is not valid PHP class name.', $class));
            }
        }

        return $class;
    }

    /**
     * Get builder class location.
     *
     * @param string $builderClass
     *
     * @return string
     *
     * @throws \RunOpenCode\AbstractBuilder\Exception\RuntimeException
     */
    private function getBuilderLocation($builderClass)
    {
        $location = $this->input->getArgument('location');

        if (null === $location && class_exists($builderClass)) {
            $location = (new \ReflectionClass($builderClass))->getFileName();
        }

        if (null === $location) {
            $helper = $this->getHelper('question');
            $question = new Question('Enter path to directory where you want to store builder class: ', null);

            $path = str_replace('\\', '/', ltrim($helper->ask($this->input, $this->output, $question), '/'));

            if (!is_dir($path)) {
                throw new RuntimeException(sprintf('Provided path "%s" is not path to directory.', $path));
            }

            if (!is_writable($path)) {
                throw new RuntimeException(sprintf('Directory on path "%s" is not writeable.', $path));
            }

            $path = $path.'/'.end(explode('/', $builderClass)).'.php';
        }

        return $location;
    }

    /**
     * Get methods which ought to be generated.
     *
     * @param string $buildingClass
     * @param string $builderClass
     *
     * @return array
     *
     * @throws \RunOpenCode\AbstractBuilder\Exception\RuntimeException
     */
    private function getMethods($buildingClass, $builderClass)
    {
        $constructorParameters = (new \ReflectionClass($buildingClass))->getConstructor()->getParameters();
        $builderMethods = class_exists($builderClass, true) ? get_class_methods($builderClass) : [];

        $methods = [];

        foreach ($constructorParameters as $parameter) {
            $getter = sprintf('get%s', ucfirst($parameter->getName()));
            $setter = sprintf('set%s', ucfirst($parameter->getName()));

            if (!in_array($getter, $builderMethods, true)) {
                $methods[] = $getter;
            }

            if (!in_array($setter, $builderMethods, true)) {
                $methods[] = $setter;
            }
        }

        if (0 === count($methods)) {
            return [];
        }

        if (true !== $this->input->getOption('all')) {

            $helper = $this->getHelper('question');
            $question = new ChoiceQuestion(
                'Choose which methods you want to generate for your builder class (separate choices with coma, enter none for all choices):',
                $methods,
                implode(',', array_keys($methods))
            );
            $question->setMultiselect(true);

            $methods = $helper->ask($this->input, $this->output, $question);
        }

        if (0 === count($methods)) {
            throw new RuntimeException('You have to choose at least one method to generate.');
        }

        return $methods;
    }
}
